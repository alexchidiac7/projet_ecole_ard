{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Projet OPTISKIN","text":"<p>Le projet OPTISKIN a \u00e9t\u00e9 con\u00e7u par le doctorant appel\u00e9 Lionel Fliegans, le sujet pr\u00e9sente un capteur optique utilisant une matrice de guides d'onde en \u00e9lastom\u00e8re, con\u00e7ue pour d\u00e9tecter le contact, la pression normale et les forces avec l'objectif principal de reproduire la perception cutan\u00e9e humaine.</p> <p>      Pendant son projet, il a d\u00e9velopp\u00e9 un circuit \u00e9lectronique connect\u00e9 \u00e0 une Raspberry Pi et un Arduino Uno pour contr\u00f4ler une machine CNC et un Ketley System. En utilisant de tout ce syst\u00e8me, il a ex\u00e9cut\u00e9 les exp\u00e9riences dont il avait besoin pour le but final de son doctorat.  </p> <p>Apr\u00e8s avoir fini son projet, la machine qu\u2019il avait con\u00e7ue a \u00e9t\u00e9 disponible pour que d\u2019autres chercheurs puissent l\u2019utiliser. Malheureusement,  \u00e0 cause de plusieurs bugs et de sa complexit\u00e9, il \u00e9t\u00e9 tr\u00e8s difficile d'ex\u00e9cuter des experiments ou d\u2019essayer n\u2019importe quoi. </p> <p>Notre objectif dans ce projet est de comprendre comment cette machine fonctionne, tant au niveau \u00e9lectronique que logiciel, et de faire des modifications pour am\u00e9liorer l'exp\u00e9rience utilisateur afin qu'elle puisse \u00eatre utilis\u00e9e par n'importe quel chercheur. </p> <p>Github avec le code du projet</p>"},{"location":"connections/","title":"Connections \u00e9lectroniques","text":"<p>Les principaux composants utilis\u00e9s dans ce projet sont les suivants : un contr\u00f4leur CNC, un CF3DN, un MGO , un Raspberry Pi 4, Keithley 2410, tout en utilisant comme langage de programmation python pour la communication avec la machine CNC</p> <p></p>"},{"location":"connections/#schema-general-de-connexion-du-projet","title":"Sch\u00e9ma g\u00e9n\u00e9ral de connexion du projet","text":""},{"location":"connections/#arduino-uno","title":"Arduino Uno","text":"<p>Il est charg\u00e9 de fournir +5V \u00e0 chacun des six phototransistors du projet et de contr\u00f4ler chaque canal disponible des phototransistors.</p> <p></p>"},{"location":"connections/#phototransitores","title":"Phototransitores","text":"<p>Un phototransistor bipolaire est essentiellement une structure de transistor \u00e9lectronique, o\u00f9 la lumi\u00e8re ext\u00e9rieure peut frapper la jonction base-collecteur. Les porteurs de charge \u00e9lectriques ainsi cr\u00e9\u00e9s sont inject\u00e9s dans la base, produisant un effet similaire \u00e0 celui d'un courant de base inject\u00e9 \u00e0 travers un fil dans un transistor ordinaire. Le courant de collecteur r\u00e9sultant montre une amplification substantielle, facilement par un facteur de 100 ou plus.</p> <p>Le phototransistor NPN tel que le WL-STSW SMT fonctionne en convertissant la lumi\u00e8re en un signal \u00e9lectrique \u00e0 travers la g\u00e9n\u00e9ration d'un courant de base, qui est ensuite amplifi\u00e9 pour produire un courant de collecteur proportionnel, fournissant un signal de sortie utilisable dans diverses applications de d\u00e9tection de lumi\u00e8re.</p> <p>Pour la lecture des signaux provenant de phototransistors int\u00e9gr\u00e9s dans des guides d'ondes, une m\u00e9thode de multiplexage s\u00e9quentiel a \u00e9t\u00e9 mise en \u0153uvre. Cette technique traite six canaux de phototransistors, qui sont aliment\u00e9s et amplifi\u00e9s \u00e0 +5V via une carte Arduino.</p>"},{"location":"connections/#74hc4051-mux","title":"74HC4051 Mux","text":"<p>Le circuit int\u00e9gr\u00e9 SOP16 interm\u00e9die les connexions entre l'Arduino Uno et les phototransistors en utilisant le CI 74HC4051. Chaque phototransistor a au moins une broche connect\u00e9e \u00e0 la broche 16 du SOP16, qui est reli\u00e9e aux 3,3V de l'Arduino Uno, et la deuxi\u00e8me broche est connect\u00e9e \u00e0 un canal de notre MUX, de sorte qu'elle peut \u00eatre contr\u00f4l\u00e9e individuellement par notre Arduino Uno.</p>"},{"location":"connections/#mgo","title":"MGO","text":"<p>Le capteur MGO a \u00e9t\u00e9 cr\u00e9\u00e9 pour recevoir et traiter les signaux optiques en r\u00e9ponse aux d\u00e9formations m\u00e9caniques. Il est \u00e9quip\u00e9 de 2 LED et de 6 phototransistors, utilis\u00e9s respectivement pour \u00e9mettre de la lumi\u00e8re blanche et convertir la lumi\u00e8re en courant \u00e9lectrique.</p> <p>Les 2 LED pr\u00e9sentes dans le MGO sont aliment\u00e9es par une alimentation stabilis\u00e9e de +3,2V.</p> <p>Les six phototransistors WL-STSW SMT (NPN) fonctionnent en convertissant la lumi\u00e8re en un signal \u00e9lectrique. Ils poss\u00e8dent uniquement deux broches et sont directement aliment\u00e9s par l'Arduino Uno via la broche 3,3V, qui est connect\u00e9e au multiplexeur amplifiant la source de sortie \u00e0 5V.</p>"},{"location":"connections/#cf3dn","title":"CF3DN","text":"<p>Le capteur de forces \u00e0 3 axes normalis\u00e9 (CF3DN) est responsable de la mesure de la force. Elle est directement connect\u00e9e \u00e0 un Arduino Nano et \u00e0 une alimentation stabilis\u00e9e. </p> <p>L'axe Z (mouvement vertical) a \u00e9t\u00e9 configur\u00e9 pour \u00eatre contr\u00f4l\u00e9 directement via une connexion s\u00e9rie avec un script Python (XYZ_Force_Sensor_test.py). Ce script permet \u00e0 la machine de descendre et de venir en contact avec le module CF3DN pour mesurer cette force.</p> <p>Les axes X et Y sont tous deux contr\u00f4l\u00e9s simultan\u00e9ment \u00e0 l'aide d'un script Python diff\u00e9rent (CNC_Gcode.py). Ce script s'ex\u00e9cute \u00e9galement avec l'interface logicielle Planet CNC.</p>"},{"location":"connections/#keithley-system-source-meter","title":"Keithley System Source Meter","text":"<p>Le Keithley mesure le courant provenant de la sortie du Mux. Le courant g\u00e9n\u00e9r\u00e9 par les phototransistors est mesur\u00e9 par une unit\u00e9 Keithley 2400, c\u00e2bl\u00e9e en configuration \u00e0 quatre fils pour augmenter la pr\u00e9cision de mesure et minimiser les probl\u00e8mes de masse entre diff\u00e9rents \u00e9quipements. La ligne de sensibilit\u00e9 HI a une entr\u00e9e \u00e0 haute imp\u00e9dance qui sert de boucle de r\u00e9troaction avec un comparateur \u00e0 l'int\u00e9rieur du Keithley pour assurer que la force appliqu\u00e9e reste stable.</p> <p>Les LED int\u00e9gr\u00e9es dans les guides d'ondes sont aliment\u00e9es par une alimentation stabilis\u00e9e \u00e0 +3,2V.</p> <p>Le taux d'acquisition de donn\u00e9es pour la lecture des six photocourants est limit\u00e9 \u00e0 2,5 Hz par le Keithley, qui est un instrument tr\u00e8s pr\u00e9cis (+10 chiffres) mais pas adapt\u00e9 aux applications \u00e0 haute fr\u00e9quence.</p>"},{"location":"fastUserGuid/","title":"Fast User Guide","text":""},{"location":"fastUserGuid/#gmo-machine-user-guide","title":"GMO Machine User Guide","text":"<p>To use the GMO machine, we first have to make sure that all the connections are set. Most probably they are, however sometimes they disconnect the Keithley (the current measurement machine). You\u2019ll have to refer to our GitHub documentation to see the connections. In summary, you need to connect the 2 pins of the Keithley to Pin 3 and Pin 8 of the Mux and also connect the ethernet of the Keithley to the Raspberry Pi.</p>"},{"location":"fastUserGuid/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Turn on:</p> <ul> <li>The Raspberry Pi</li> <li>The DC Supply System</li> <li>The Keithley System Source</li> </ul> </li> <li> <p>Open a Terminal in the Raspberry Pi system</p> </li> <li>Navigate to the Folder <code>test_projet_ecole</code><ul> <li><code>cd test_projet_ecole</code></li> </ul> </li> <li>Using Git<ul> <li>We use git to push/pull updates to this project.</li> <li>The <code>master</code> branch was used for documentation.</li> <li>The main code branch is <code>alex-app-2</code>.</li> <li>The interface is in the <code>app.py</code> file.</li> </ul> </li> <li>Run the Interface<ul> <li><code>python3 app.py</code></li> </ul> </li> </ol>"},{"location":"fastUserGuid/#starting-the-simulation","title":"Starting the Simulation","text":"<p>Assuming you know the basics, this user guide is a summary of a much larger one. Refer to the other, more comprehensive document for a concrete example.</p>"},{"location":"fastUserGuid/#step-1-positionning-the-cnc-machine","title":"Step 1: Positionning the CNC Machine","text":"<ol> <li>Initial Position<ul> <li>Save coordinates (enter them in the \u201cAdd G-codes\u201d rows and then click \u201cSave G-codes to file\u201d).</li> </ul> </li> <li>Run CNC<ul> <li>This moves the machine to the saved coordinates in the txt files.</li> </ul> </li> <li>Re-save New Coordinates<ul> <li>These coordinates will serve as position number 2.</li> </ul> </li> </ol>"},{"location":"fastUserGuid/#step-2-start-the-simulation","title":"Step 2: Start the Simulation","text":"<ol> <li>Enter a Force (in Newtons)</li> <li>Click \u2018Submit Z-axis Force\u2019</li> <li>Start Taking Measurements<ul> <li>After a couple of seconds, click \u2018Run Keithley\u2019.</li> </ul> </li> <li>Move the Machine<ul> <li>When the machine hits the surface of the GMO, click \u2018Run CNC\u2019.</li> <li>If the machine didn\u2019t move, it means you didn\u2019t update your coordinates.</li> </ul> </li> <li>End the Simulation<ul> <li>When you arrive at the desired position, click \u2018Stop simulation\u2019 or press <code>CTRL+C</code> in your terminal.</li> <li>This completes the full simulation.</li> </ul> </li> </ol>"},{"location":"fastUserGuid/#step-3-generate-graphs","title":"Step 3: Generate Graphs","text":""},{"location":"fastUserGuid/#view-your-simulation-measurements","title":"View Your Simulation Measurements","text":"<ol> <li> <p>Run Forces Plotter</p> <ul> <li>Click on \"Run Forces Plotter\".</li> <li>Choose the file in <code>mesures_XYZ</code> (select the latest one related to your simulation).</li> <li>This will generate a graph of forces Fx, Fy, and Fz.</li> </ul> </li> <li> <p>Run Waveguide Loss Plotter</p> <ul> <li>Click on \u201cRun Waveguide Loss Plotter\u201d.</li> <li>Choose the file in <code>mesures_MUX</code> (select the latest one related to your simulation).</li> </ul> </li> </ol> <p>This is a brief explanation. Refer to the more comprehensive documentation with a concrete example for a better understanding.</p>"},{"location":"simulation/","title":"Simulation","text":"<p>Pour un exemple concret, nous voulons faire la simulation suivante:</p> <p>     La premi\u00e8re mesure devait se faire de gauche \u00e0 droite (E3 ver L2) comme indiqu\u00e9 sur la figure par le signe plus en forme, avec une force de 3N.  </p> <p>Pour commencer, ex\u00e9cutez le fichier appel\u00e9 `app.py et suivre le \u00e9tapes suivantes:</p> <ol> <li>Cliquez sur \u201cAdd G-code Inputs\u201d pour ajouter une ligne.</li> <li>Entrez <code>0</code>, <code>-0.5</code>, et <code>1000</code> dans les cases de X, Y, et Vitesse respectivement.</li> <li>Cliquez sur \u201cSave G-codes to File\u201d</li> <li>Ex\u00e9cutez le script en cliquant Run CNC.</li> </ol> <p>Cela va d\u00e9placer la machine vers les coordonn\u00e9es enregistr\u00e9es. Une fois que la machine s'est d\u00e9plac\u00e9e vers la position enregistr\u00e9e, nous devons maintenant saisir le num\u00e9ro de position 2, qui est la position finale de cette machine. N'oubliez pas que nous devons consid\u00e9rer les coordonn\u00e9es comme absolues (l'origine est fixe)</p> <p>Nous devons donc maintenant saisir les coordonn\u00e9es de la position 2 qui sont (-3;-0,5)</p> <ol> <li>Click on \u201cClear G-code Inputs\u201d (pour tout supprimer et recommencer.)</li> <li>Click on \u201cAdd G-code Inputs\u201d</li> <li>Enter <code>-3</code>, <code>-0.5</code>, <code>1000</code> in the fields for X, Y, and Speed respectively</li> <li>Click on \u201cSave G-codes to File\u201d</li> </ol> <p>Ne cliquez pas sur \"Run CNC\" car cela sera fait plus tard dans la simulation, pour l'instant nous positionnons simplement la machine sur la position 1 et enregistrons les coordonn\u00e9es de la position 2. Maintenant que la machine est en position 1 et que les coordonn\u00e9es de la position 2 sont enregistr\u00e9es, nous pouvons d\u00e9marrer la simulation.</p> <p>Assurez-vous que la jauge de l'axe Z ne touche pas le mat\u00e9riau. (montez-le manuellement si c'est le cas)</p> <p></p>"},{"location":"simulation/#une-simulation-complete","title":"Une simulation compl\u00e8te","text":"<ol> <li>Mettez la Force. (ex : 3) -&gt; (ce qui signifie 3N)</li> <li>Cliquez sur \"Soumettre la force de l'axe Z\"</li> </ol> <p>Ici, la machine commencera \u00e0 descendre dans la direction du mat\u00e9riau.</p> <p>Avant de toucher le mat\u00e9riau, il faut \"Run Keithley\" pour commencer \u00e0 mesurer le courant sur le phototransistor. Nous faisons cela avant de toucher le mat\u00e9riau pour prendre les premi\u00e8res valeurs enregistr\u00e9es comme r\u00e9f\u00e9rence, ce qui sera n\u00e9cessaire pour des mesures correctes ult\u00e9rieurement.</p> <ol> <li>Cliquez sur \"Run Keithley\" avant de toucher le mat\u00e9riel</li> <li>Lorsque la jauge Z touche le mat\u00e9riau, attendez une seconde puis \"Run CNC\"    Cela commencera \u00e0 d\u00e9placer la machine vers la position 2</li> <li>Lorsque vous atteignez la position souhait\u00e9e, cliquez sur \"Stop Simulation\"</li> </ol> <p>F\u00e9licitations, vous venez de terminer une simulation enti\u00e8re.</p>"},{"location":"simulation/#faire-les-mesures","title":"Faire les mesures","text":"<p>Maintenant pour voir les mesures de votre simulation :</p> <ol> <li>Cliquez sur \"Run Forces Plotter\"</li> <li>Choisissez le fichier dans mesures_XYZ (vous devez choisir le plus r\u00e9cent, li\u00e9 \u00e0 votre simulation)</li> </ol> <p>En saisissant cela, vous obtiendrez un graphique, c'est le graphique des forces Fx, Fy et Fz.</p> <p>Le m\u00eame pour \"Run Waveguide Loss Plotter\" :</p> <ol> <li>Cliquez sur \"Run Waveguide Loss Plotter\"</li> <li>Choisissez le fichier dans mesures_MUX (vous devez choisir le plus r\u00e9cent, li\u00e9 \u00e0 votre simulation)</li> </ol> <p>En saisissant cela, vous obtiendrez un graphique, c'est le graphique des pertes dans chaque canal des phototransistors (les pertes li\u00e9es au courant enregistr\u00e9 par les phototransistors). C'est pourquoi nous avons dit qu'il fallait \"Ex\u00e9cuter Keithley\" avant de toucher le mat\u00e9riau, car nous avions besoin d'une valeur de r\u00e9f\u00e9rence pour calculer la perte, cette valeur de r\u00e9f\u00e9rence \u00e9tant la valeur initiale enregistr\u00e9e par chaque canal avant de toucher le mat\u00e9riau.</p> <p>C'est un exemple simple, mais c'est ainsi que sont effectu\u00e9es 90% des mesures. Vous passez simplement de la position 1 \u00e0 la position 2. Maintenant, avec l'interface que nous avons cr\u00e9\u00e9e, elle est dynamique, donc vous pouvez passer \u00e0 la position 1, puis au lieu de sauvegarder la position 2 souhait\u00e9e, vous pouvez sauvegarder plusieurs positions, par exemple :</p> <p></p> <p>Quand on clique sur \u201cSave G-codes\u201d et quand au milieu de la simulation on clique sur \u201cRun CNC\u201d, il passera de la position 1 (d\u00e9plac\u00e9e avant de d\u00e9marrer la simulation) \u00e0 la position 2 (-3;-0,5), attendra 5 secondes, puis \u00e0 (-5;-0,5).</p> <p>La vitesse est 1000 pour notre exemple, c'est la plus utilis\u00e9e. Vous pouvez l'augmenter \u00e0 2000 pour des mouvements plus rapides ou la diminuer \u00e0 500 pour des mouvements plus lents. Nous avons enregistr\u00e9 ces valeurs pour chaque vitesse :</p> <ul> <li>Vitesse de 1000 : il bouge de 10 cm en 37s, soit 0.270 cm/s ou 2.70 mm/s.</li> <li>Vitesse de 2000 : il bouge de 10 cm en 18s, soit 0.5 cm/s ou 5.5 mm/s.</li> <li>Vitesse de 4000 : il bouge de 10 cm en 15s, soit 0.6 cm/s ou 6.6 mm/s.</li> </ul>"},{"location":"simulation/#conseils","title":"Conseils","text":"<p>Il y a un grand bouton rouge dans la machine, il est utilis\u00e9 pour arr\u00eater les axes X et Y.</p> <p>L'axe Z peut \u00eatre arr\u00eat\u00e9 en utilisant le bouton \"Stop Simulation\" dans l'interface. Si l'axe continue \u00e0 descendre, il faut red\u00e9marrer tout le Raspberry Pi.</p> <p>Quand le c\u00e2ble r\u00e9seau n'est pas connect\u00e9 au Raspberry Pi, il y a un bug qui rend tout le syst\u00e8me plus lent.</p>"}]}